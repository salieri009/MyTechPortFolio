# Azure Pipelines CI/CD for MyPortFolio
# Multi-stage pipeline with Build, Test, and Deploy stages
# Follows 20-year DevOps and Software Engineer best practices

trigger:
  branches:
    include:
      - main
      - develop
  paths:
    include:
      - backend/**
      - frontend/**
      - azure-pipelines.yml
      - .azure/pipelines/**
      - infra/**

pr:
  branches:
    include:
      - main
      - develop
  paths:
    include:
      - backend/**
      - frontend/**

variables:
  - group: 'Portfolio-Pipeline-Variables'
  - name: buildConfiguration
    value: 'Release'
  - name: vmImage
    value: 'ubuntu-latest'
  # Gradle Cache Settings
  - name: GRADLE_USER_HOME
    value: $(Pipeline.Workspace)/.gradle

# Key Vault integration is handled via the Variable Group 'Portfolio-Pipeline-Variables' linked above.
# Secrets are automatically available as environment variables in tasks that request them.

stages:
  # Stage 1: Build
  # Parallel builds for backend and frontend
  - stage: Build
    displayName: 'Build Stage'
    jobs:
      - job: BuildBackend
        displayName: 'Build Backend'
        pool:
          vmImage: $(vmImage)
        steps:
          # Optimization: Cache Gradle dependencies
          - task: Cache@2
            displayName: 'Cache Gradle packages'
            inputs:
              key: 'gradle | "$(Agent.OS)" | backend/build.gradle'
              restoreKeys: |
                gradle | "$(Agent.OS)"
              path: $(GRADLE_USER_HOME)
          
          - template: .azure/pipelines/templates/build-docker-image.yml
            parameters:
              workingDirectory: 'backend'
              dockerfilePath: 'backend/Dockerfile'
              imageName: 'portfolio-backend'
              containerRegistry: 'ACR_Connection'
              tags:
                - $(Build.BuildId)
                - $(Build.SourceBranchName)
                - latest

      - job: BuildFrontend
        displayName: 'Build Frontend'
        pool:
          vmImage: $(vmImage)
        steps:
          # Optimization: Cache NPM dependencies
          - task: Cache@2
            displayName: 'Cache NPM packages'
            inputs:
              key: 'npm | "$(Agent.OS)" | frontend/package-lock.json'
              restoreKeys: |
                npm | "$(Agent.OS)"
              path: $(HOME)/.npm

          - template: .azure/pipelines/templates/build-docker-image.yml
            parameters:
              workingDirectory: 'frontend'
              dockerfilePath: 'frontend/Dockerfile'
              imageName: 'portfolio-frontend'
              containerRegistry: 'ACR_Connection'
              buildArgs:
                VITE_API_BASE_URL: '$(VITE_API_BASE_URL)'
                VITE_GOOGLE_CLIENT_ID: '$(VITE_GOOGLE_CLIENT_ID)'
                VITE_GA_MEASUREMENT_ID: '$(VITE_GA_MEASUREMENT_ID)'
                VITE_USE_BACKEND_API: 'true'
              tags:
                - $(Build.BuildId)
                - $(Build.SourceBranchName)
                - latest

  # Stage 2: Test
  - stage: Test
    displayName: 'Test Stage'
    dependsOn: Build
    jobs:
      - job: BackendUnitTests
        displayName: 'Backend Unit Tests'
        pool:
          vmImage: $(vmImage)
        steps:
          - template: .azure/pipelines/test-cases/backend-unit-tests.yml
            parameters:
              workingDirectory: 'backend'

      - job: BackendIntegrationTests
        displayName: 'Backend Integration Tests'
        pool:
          vmImage: $(vmImage)
        steps:
          - template: .azure/pipelines/test-cases/backend-integration-tests.yml
            parameters:
              workingDirectory: 'backend'

      - job: FrontendUnitTests
        displayName: 'Frontend Unit Tests'
        pool:
          vmImage: $(vmImage)
        steps:
          - template: .azure/pipelines/test-cases/frontend-unit-tests.yml
            parameters:
              workingDirectory: 'frontend'

      - job: FrontendIntegrationTests
        displayName: 'Frontend Integration Tests'
        pool:
          vmImage: $(vmImage)
        steps:
          - template: .azure/pipelines/test-cases/frontend-integration-tests.yml
            parameters:
              workingDirectory: 'frontend'

      - job: SecurityScanning
        displayName: 'Security Scanning'
        pool:
          vmImage: $(vmImage)
        steps:
          - template: .azure/pipelines/templates/security-scan.yml
            parameters:
              backendImage: '$(ACR_NAME).azurecr.io/portfolio-backend:$(Build.BuildId)'
              frontendImage: '$(ACR_NAME).azurecr.io/portfolio-frontend:$(Build.BuildId)'
              containerRegistry: 'ACR_Connection'

      - job: E2ETests
        displayName: 'End-to-End Tests'
        pool:
          vmImage: $(vmImage)
        # Best Practice: Run E2E tests only on main or when specifically requested, to save time/cost
        condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
        steps:
          - template: .azure/pipelines/test-cases/e2e-tests.yml

  # Stage 3: Deploy
  # Best Practice: Sequential deployment for non-prod environments (Dev -> Staging)
  - stage: DeployDev
    displayName: 'Deploy to Dev'
    dependsOn: Test
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/develop'))
    jobs:
      - deployment: DeployDev
        displayName: 'Deploy to Dev Environment'
        environment: 'dev'
        pool:
          vmImage: $(vmImage)
        strategy:
          runOnce:
            deploy:
              steps:
                - template: .azure/pipelines/templates/deploy-container-app.yml
                  parameters:
                    environment: 'dev'
                    backendAppName: '$(BACKEND_APP_NAME_DEV)'
                    frontendAppName: '$(FRONTEND_APP_NAME_DEV)'
                    containerRegistry: 'ACR_Connection'
                    backendImage: '$(ACR_NAME).azurecr.io/portfolio-backend:$(Build.BuildId)'
                    frontendImage: '$(ACR_NAME).azurecr.io/portfolio-frontend:$(Build.BuildId)'
                    resourceGroup: '$(RESOURCE_GROUP_DEV)'
                    containerAppEnv: '$(CONTAINER_APP_ENV_DEV)'

  - stage: DeployStaging
    displayName: 'Deploy to Staging'
    # Best Practice: Ensure Staging deploys only after Dev succeeds
    dependsOn: DeployDev
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/develop'))
    jobs:
      - deployment: DeployStaging
        displayName: 'Deploy to Staging Environment'
        environment: 'staging'
        pool:
          vmImage: $(vmImage)
        strategy:
          runOnce:
            deploy:
              steps:
                - template: .azure/pipelines/templates/deploy-container-app.yml
                  parameters:
                    environment: 'staging'
                    backendAppName: '$(BACKEND_APP_NAME_STAGING)'
                    frontendAppName: '$(FRONTEND_APP_NAME_STAGING)'
                    containerRegistry: 'ACR_Connection'
                    backendImage: '$(ACR_NAME).azurecr.io/portfolio-backend:$(Build.BuildId)'
                    frontendImage: '$(ACR_NAME).azurecr.io/portfolio-frontend:$(Build.BuildId)'
                    resourceGroup: '$(RESOURCE_GROUP_STAGING)'
                    containerAppEnv: '$(CONTAINER_APP_ENV_STAGING)'

  - stage: DeployProduction
    displayName: 'Deploy to Production'
    dependsOn: Test
    # Best Practice: Production deployment only from main branch
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - deployment: DeployProduction
        displayName: 'Deploy to Production Environment'
        environment: 'production'
        pool:
          vmImage: $(vmImage)
        strategy:
          runOnce:
            deploy:
              steps:
                - template: .azure/pipelines/templates/deploy-container-app.yml
                  parameters:
                    environment: 'production'
                    backendAppName: '$(BACKEND_APP_NAME_PROD)'
                    frontendAppName: '$(FRONTEND_APP_NAME_PROD)'
                    containerRegistry: 'ACR_Connection'
                    backendImage: '$(ACR_NAME).azurecr.io/portfolio-backend:$(Build.BuildId)'
                    frontendImage: '$(ACR_NAME).azurecr.io/portfolio-frontend:$(Build.BuildId)'
                    resourceGroup: '$(RESOURCE_GROUP_PROD)'
                    containerAppEnv: '$(CONTAINER_APP_ENV_PROD)'
